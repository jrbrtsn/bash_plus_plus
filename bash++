############################################################
# Bash resources you can 'source' from your Bash script.
#
# John Robertson <john@rrci.com>
# Initial release: Thu Sep 10 11:58:23 EDT 2020
#
# Fri Sep 11 22:13:16 EDT 2020
# Added malloc, new, delete, call, and fetch
#

# You can check this to see if bash++ has been sourced
BASH_PLUS_PLUS=true

# Global array to use as a return stack
declare -a __RTN_STK

function RTN_empty
############################################################
# Return logical TRUE if stack is empty, FALSE otherwise
# Arguments:
#    none
#
{
   local rtn=0
   [[ -n "${__RTN_STK:+foo}" ]] && rtn=1
   return $rtn
}

function RTN_push
############################################################
# Use this to push things onto the global return stack
# Arguments:
#    Whatever strings you wish placed on the stack
#
{
   local __opts=$(shopt -o -p nounset errexit)

   set -ue

   # For readability, store array index value here before using
   local -i ndx
   ndx=${__RTN_STK:+${#__RTN_STK[@]}}

   # Push arguments onto the stack
   while [[ -n "${1:+foo}" ]]; do

      # Place argument onto stack
      __RTN_STK[$ndx]="$1"

      ((++ndx))
      # Discard argument
      shift

   done

   # Restore options
   eval $__opts
}

function BackTrace
############################################################
# Generate a GDB(ish) style stack dump
{
   local i j

   1>&2 echo "----------- Stack Dump ------------"
   for ((i= 1; i < ${#BASH_SOURCE[@]}; ++i)); do

      ((j= i-1)) || true

      1>&2 echo -e "\ti=$i, j=$j ${BASH_SOURCE[$i]}:${BASH_LINENO[$j]} ${FUNCNAME[$i]} ()"
   done
}

function RTN_pop
############################################################
# Use this to pop things off of the return stack
# Arguments:
#    Names of global varibles to be loaded by popping
#    strings from the stack.
#
{
   # Necessary to avoid "unbound variable" exception
   local __opts=$(shopt -o -p nounset)
   set -u

   local -i arg ndx sz

   # Get current size of stack
   sz=${__RTN_STK:+${#__RTN_STK[@]}}

   # Generate correct array index
   (( ndx = sz - 1 )) || true

#1>&2  echo; declare -p sz ndx
#1>&2 read -p "$BASH_SOURCE:$LINENO  $FUNCNAME() OK? " 
   # Walk through supplied references backwards
   for (( arg= $#; arg ; --arg )); do

      if ((ndx < 0)); then
         local line file
         # Print out a stack dump
#1>&2  echo; declare -p __RTN_STK sz
#1>&2 read -p "$BASH_SOURCE:$LINENO  $FUNCNAME() OK? " 
         BackTrace
         read line file < <(caller)
         die "ERROR: ndx= '$ndx' cannot have a negative value; called from $file:$line"
      fi

      # Copy item on stack to *reference
      eval ${!arg}="\${__RTN_STK[\$ndx]}"

      # pop item from stack, free memory
      unset __RTN_STK[$ndx]
      ((--ndx)) || true
   done

   # Restore options
   eval $__opts
}

# Global heap counter integer 
declare -i __HC=0

function malloc
############################################################
# Allocate a global "address" from the "heap"
# Arguments:
#    0 or more flags which will be passed to the 'declare' builtin.
#      e.g. '-A' for associative array 
# Returns:
#   "address" of allocated memory
#
{
   # Increment global heap counter
   (( ++__HC ))

   # compose unique "address" for this allocation
   local addr="__heap_${__HC}"

   # "allocate" object gets marked for global visibility,
   # and possibly other 'declare' flags
   declare -g $@ $addr
   # push "address" onto result stack
   RTN_push $addr
}

function new ()
############################################################
# 'new' operator to allocate object & call class constructor
# Arguments:
#   classname
#   constructor_arg1         (optional)
#   ...
# Returns:
#   "address" of new object
#
{
   # Stash the class name with the object
   local __class=$1

   # Discard class name from argv
   shift

   # Allocate an associative array from our "heap"
   malloc -A

   # Retrieve "address" of new object
   RTN_pop __R1

   # Imprint class name on the object
   eval $__R1[__class]=$__class

   # Call class constructor
   eval $__class::$__class $__R1  \$@

   # Push address on return stack
   RTN_push $__R1

}

function delete ()
############################################################
# 'delete' operator to call class destructor, free object
# Arguments:
#   object_address
# Returns:
#   nothing
#
{
   # address of object
   local this=$1

   # class name of object
   eval local __class=\${$this[__class]}

   # Call class destructor
   eval $__class::~$__class $this

   # Free object memory
   unset $this
}


function show ()
############################################################
# Print object contents
# Arguments:
#   object1_address
#   object2_address (optional)
#   ...
# Returns:
#   Nothing
#
{
   declare -p $@
}

function fetch ()
############################################################
# Convenient way to access class member values
# Arguments:
#   address.member
# Returns:
#   value of member on the return stack
#
{
   # address of object
   local this=${1%.?*} __member=${1#?*.}

   eval RTN_push \"\${$this[$__member]}\"

}

function call ()
############################################################
# Call an object member function
# Arguments:
#   address.funcName
#   func_arg1 (optional)
#   ...
# Returns:
#   Whatever funcName() returns
#
{
   # address of object
   local this=${1%.?*} __func=${1#?*.}
   # class name of object
   eval local __class=\${$this[__class]}

   shift

   # Call class member function
   eval $__class::$__func $this \$@
}

function regex_read ()
############################################################
# Similar to bash 'read' builtin, but parses subsequent
# read buffer using the supplied regular expression.
# Arguments:
#   regex pattern
# Returns:
#   logical TRUE if read was successful
#   or logical FALSE on end-of-file condition.
# Return stack:
#   Full string match (if any)
#   token1_match (if any)
#   ...
#   Last argument is _always_ number of matches found. Pop it first.
#   
{
   # Stash the regular expression
   local ndx count regex="$1"

   # All other args are for 'read'
   shift

   # Call read with other supplied args. Fails on EOF
   IFS= read $@ || return 1

   # Apply regular expression parsing to read buffer
   if [[ $REPLY =~ $regex ]]; then
      # Place results on return stack
      count=${#BASH_REMATCH[@]}
      for (( ndx= 0; ndx < count; ++ndx )); do
         RTN_push "${BASH_REMATCH[$ndx]}"
      done
      # Last stack arg is number of match results
      RTN_push $count

   else
      # regex failed to match
      RTN_push 0
   fi
}

function die ()
############################################################
# Same as 'die' in perl - Print supplied args to stderr
# prefixed with source file name and line number,
# then exit indicating error.
#
{
   local line file
   read line file < <(caller)
   1>&2 echo "$file:$line $@"
   exit 1
}

